import sqlite3
import json
import numpy as np
from typing import List, Dict, Optional, Tuple
from datetime import datetime
import os
import glob

class DatabaseManager:
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö —Å –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–º–∏ —Ç–∞–±–ª–∏—Ü–∞–º–∏"""
        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)
        
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            
            # –¢–∞–±–ª–∏—Ü–∞ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS documents (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    filename TEXT UNIQUE NOT NULL,
                    title TEXT,
                    content TEXT NOT NULL,
                    file_size INTEGER,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # –¢–∞–±–ª–∏—Ü–∞ —á–∞–Ω–∫–æ–≤ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS document_chunks (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    document_id INTEGER NOT NULL,
                    chunk_index INTEGER NOT NULL,
                    content TEXT NOT NULL,
                    start_position INTEGER NOT NULL,
                    end_position INTEGER NOT NULL,
                    chunk_size INTEGER NOT NULL,
                    embedding BLOB,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (document_id) REFERENCES documents (id) ON DELETE CASCADE,
                    UNIQUE(document_id, chunk_index)
                )
            ''')
            
            # –¢–∞–±–ª–∏—Ü–∞ –¥–ª—è –∏—Å—Ç–æ—Ä–∏–∏ —á–∞—Ç–æ–≤
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS chat_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    session_id TEXT NOT NULL,
                    user_query TEXT NOT NULL,
                    ai_response TEXT NOT NULL,
                    sources TEXT, -- JSON –º–∞—Å—Å–∏–≤ –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –ø–æ–∏—Å–∫–∞
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_chunks_document_id ON document_chunks(document_id)')
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_chat_session ON chat_history(session_id)')
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_documents_filename ON documents(filename)')
            
            conn.commit()
            
        # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –ø—Ä–∏ –ø—É—Å—Ç–æ–π –±–∞–∑–µ
        self._auto_populate_if_empty()
    
    def _auto_populate_if_empty(self):
        """–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –µ—Å–ª–∏ –±–∞–∑–∞ –ø—É—Å—Ç–∞—è"""
        stats = self.get_documents_stats()
        if stats['documents_count'] == 0:
            print("üìù –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –ø—É—Å—Ç–∞—è, –Ω–∞—á–∏–Ω–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫—É—é –∑–∞–≥—Ä—É–∑–∫—É –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤...")
            self.bulk_load_documents_from_directory('current')
    
    def bulk_load_documents_from_directory(self, directory: str, limit: int = None):
        """–ú–∞—Å—Å–æ–≤–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –∏–∑ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏"""
        if not os.path.exists(directory):
            print(f"‚ö†Ô∏è  –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è {directory} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
            return {'loaded': 0, 'errors': []}
        
        txt_files = glob.glob(os.path.join(directory, '*.txt'))
        
        if limit:
            txt_files = txt_files[:limit]
        
        if not txt_files:
            print(f"üìÅ –í –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ {directory} –Ω–µ—Ç .txt —Ñ–∞–π–ª–æ–≤")
            return {'loaded': 0, 'errors': []}
        
        print(f"üìö –ù–∞–π–¥–µ–Ω–æ {len(txt_files)} –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏")
        
        loaded = 0
        errors = []
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –¥–ª—è –º–∞—Å—Å–æ–≤–æ–π –≤—Å—Ç–∞–≤–∫–∏
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            
            for i, file_path in enumerate(txt_files):
                try:
                    filename = os.path.basename(file_path)
                    
                    # –ß–∏—Ç–∞–µ–º —Ñ–∞–π–ª
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read().strip()
                    
                    if not content:
                        continue
                    
                    # –ò–∑–≤–ª–µ–∫–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ –∏–∑ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
                    title = self._extract_title_from_filename(filename)
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞
                    cursor.execute('SELECT id FROM documents WHERE filename = ?', (filename,))
                    if cursor.fetchone():
                        continue  # –î–æ–∫—É–º–µ–Ω—Ç —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
                    
                    # –í—Å—Ç–∞–≤–ª—è–µ–º –¥–æ–∫—É–º–µ–Ω—Ç
                    cursor.execute('''
                        INSERT INTO documents (filename, title, content, file_size)
                        VALUES (?, ?, ?, ?)
                    ''', (filename, title, content, len(content)))
                    
                    loaded += 1
                    
                    if (i + 1) % 100 == 0:
                        print(f"  üìÑ –ó–∞–≥—Ä—É–∂–µ–Ω–æ {i + 1}/{len(txt_files)} –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤...")
                        conn.commit()  # –ü—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–π commit
                    
                except Exception as e:
                    error_msg = f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ {file_path}: {str(e)}"
                    errors.append(error_msg)
                    print(f"  ‚ùå {error_msg}")
            
            conn.commit()
        
        print(f"‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ {loaded} –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö")
        if errors:
            print(f"‚ö†Ô∏è  –û—à–∏–±–æ–∫: {len(errors)}")
        
        return {'loaded': loaded, 'errors': errors}
    
    def _extract_title_from_filename(self, filename: str) -> str:
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —á–∏—Ç–∞–µ–º–æ–≥–æ –Ω–∞–∑–≤–∞–Ω–∏—è –∏–∑ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞"""
        title = os.path.splitext(filename)[0]
        
        # –ò—â–µ–º –ø–∞—Ç—Ç–µ—Ä–Ω "–Ω–∞–∑–≤–∞–Ω–∏–µ –ù–æ–≤—ã–π –æ–ø–∏—Å–∞–Ω–∏–µ"
        if " –ù–æ–≤—ã–π " in title:
            parts = title.split(" –ù–æ–≤—ã–π ")
            return parts[0].strip()
        
        # –£–±–∏—Ä–∞–µ–º –ª–∏—à–Ω–∏–µ —Å–∏–º–≤–æ–ª—ã –∏ –¥–µ–ª–∞–µ–º —á–∏—Ç–∞–µ–º—ã–º
        title = title.replace('_', ' ').replace('-', ' ')
        return title.strip()
    
    def get_unprocessed_documents(self) -> List[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –±–µ–∑ —á–∞–Ω–∫–æ–≤ (–Ω–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö)"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT d.id, d.filename, d.title, d.content
                FROM documents d
                LEFT JOIN document_chunks dc ON d.id = dc.document_id
                WHERE dc.document_id IS NULL
                ORDER BY d.created_at
            ''')
            
            documents = []
            for row in cursor.fetchall():
                documents.append({
                    'id': row[0],
                    'filename': row[1],
                    'title': row[2],
                    'content': row[3]
                })
            
            return documents
    
    def bulk_insert_chunks(self, chunks_data: List[Dict]):
        """–ú–∞—Å—Å–æ–≤–∞—è –≤—Å—Ç–∞–≤–∫–∞ —á–∞–Ω–∫–æ–≤"""
        if not chunks_data:
            return
        
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            
            # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –º–∞—Å—Å–æ–≤–æ–π –≤—Å—Ç–∞–≤–∫–∏
            insert_data = []
            for chunk in chunks_data:
                embedding_blob = None
                if chunk.get('embedding') is not None:
                    embedding_blob = chunk['embedding'].tobytes()
                
                insert_data.append((
                    chunk['document_id'],
                    chunk['chunk_index'],
                    chunk['content'],
                    chunk['start_position'],
                    chunk['end_position'],
                    chunk['chunk_size'],
                    embedding_blob
                ))
            
            # –ú–∞—Å—Å–æ–≤–∞—è –≤—Å—Ç–∞–≤–∫–∞
            cursor.executemany('''
                INSERT OR REPLACE INTO document_chunks 
                (document_id, chunk_index, content, start_position, end_position, chunk_size, embedding)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            ''', insert_data)
            
            conn.commit()
            print(f"üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ {len(chunks_data)} —á–∞–Ω–∫–æ–≤ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö")
    
    def insert_document(self, filename: str, content: str, title: str = None) -> int:
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –¥–æ–∫—É–º–µ–Ω—Ç
            cursor.execute('SELECT id FROM documents WHERE filename = ?', (filename,))
            existing = cursor.fetchone()
            
            if existing:
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –¥–æ–∫—É–º–µ–Ω—Ç
                cursor.execute('''
                    UPDATE documents 
                    SET content = ?, title = ?, file_size = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE filename = ?
                ''', (content, title or filename, len(content), filename))
                document_id = existing[0]
                
                # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ —á–∞–Ω–∫–∏
                cursor.execute('DELETE FROM document_chunks WHERE document_id = ?', (document_id,))
            else:
                # –í—Å—Ç–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π –¥–æ–∫—É–º–µ–Ω—Ç
                cursor.execute('''
                    INSERT INTO documents (filename, title, content, file_size)
                    VALUES (?, ?, ?, ?)
                ''', (filename, title or filename, content, len(content)))
                document_id = cursor.lastrowid
            
            conn.commit()
            return document_id
    
    def insert_chunk(self, document_id: int, chunk_index: int, content: str, 
                    start_pos: int, end_pos: int, embedding: np.ndarray = None) -> int:
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ —á–∞–Ω–∫–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            
            embedding_blob = None
            if embedding is not None:
                embedding_blob = embedding.tobytes()
            
            cursor.execute('''
                INSERT OR REPLACE INTO document_chunks 
                (document_id, chunk_index, content, start_position, end_position, chunk_size, embedding)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            ''', (document_id, chunk_index, content, start_pos, end_pos, len(content), embedding_blob))
            
            chunk_id = cursor.lastrowid
            conn.commit()
            return chunk_id
    
    def get_document_by_filename(self, filename: str) -> Optional[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞ –ø–æ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT id, filename, title, content, file_size, created_at, updated_at
                FROM documents WHERE filename = ?
            ''', (filename,))
            
            row = cursor.fetchone()
            if row:
                return {
                    'id': row[0],
                    'filename': row[1],
                    'title': row[2],
                    'content': row[3],
                    'file_size': row[4],
                    'created_at': row[5],
                    'updated_at': row[6]
                }
            return None
    
    def get_all_chunks(self) -> List[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö —á–∞–Ω–∫–æ–≤ (–±–µ–∑ embeddings) –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT dc.id, dc.document_id, dc.chunk_index, dc.content, 
                       dc.start_position, dc.end_position,
                       d.filename, d.title
                FROM document_chunks dc
                JOIN documents d ON dc.document_id = d.id
                ORDER BY d.filename, dc.chunk_index
            ''')
            
            chunks = []
            for row in cursor.fetchall():
                chunks.append({
                    'id': row[0],
                    'document_id': row[1],
                    'chunk_index': row[2],
                    'content': row[3],
                    'start_position': row[4],
                    'end_position': row[5],
                    'filename': row[6],
                    'title': row[7]
                })
            
            return chunks

    def get_all_chunks_with_embeddings(self) -> List[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö —á–∞–Ω–∫–æ–≤ —Å embeddings –¥–ª—è –ø–æ–∏—Å–∫–∞"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT dc.id, dc.document_id, dc.chunk_index, dc.content, 
                       dc.start_position, dc.end_position, dc.embedding,
                       d.filename, d.title
                FROM document_chunks dc
                JOIN documents d ON dc.document_id = d.id
                WHERE dc.embedding IS NOT NULL
                ORDER BY d.filename, dc.chunk_index
            ''')
            
            chunks = []
            for row in cursor.fetchall():
                embedding = None
                if row[6]:  # embedding blob
                    embedding = np.frombuffer(row[6], dtype=np.float32)
                
                chunks.append({
                    'id': row[0],
                    'document_id': row[1],
                    'chunk_index': row[2],
                    'content': row[3],
                    'start_position': row[4],
                    'end_position': row[5],
                    'embedding': embedding,
                    'filename': row[7],
                    'title': row[8]
                })
            
            return chunks
    
    def get_chunk_by_id(self, chunk_id: int) -> Optional[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —á–∞–Ω–∫–∞ –ø–æ ID"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT dc.id, dc.document_id, dc.chunk_index, dc.content, 
                       dc.start_position, dc.end_position,
                       d.filename, d.title
                FROM document_chunks dc
                JOIN documents d ON dc.document_id = d.id
                WHERE dc.id = ?
            ''', (chunk_id,))
            
            row = cursor.fetchone()
            if row:
                return {
                    'id': row[0],
                    'document_id': row[1],
                    'chunk_index': row[2],
                    'content': row[3],
                    'start_position': row[4],
                    'end_position': row[5],
                    'filename': row[6],
                    'title': row[7]
                }
            return None
    
    def save_chat_history(self, session_id: str, user_query: str, 
                         ai_response: str, sources: List[Dict] = None):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ —á–∞—Ç–∞"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            
            sources_json = json.dumps(sources, ensure_ascii=False) if sources else None
            
            cursor.execute('''
                INSERT INTO chat_history (session_id, user_query, ai_response, sources)
                VALUES (?, ?, ?, ?)
            ''', (session_id, user_query, ai_response, sources_json))
            
            conn.commit()
    
    def get_chat_history(self, session_id: str, limit: int = 10) -> List[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ —á–∞—Ç–∞ –¥–ª—è —Å–µ—Å—Å–∏–∏"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute('''
                SELECT user_query, ai_response, sources, created_at
                FROM chat_history 
                WHERE session_id = ?
                ORDER BY created_at DESC
                LIMIT ?
            ''', (session_id, limit))
            
            history = []
            for row in cursor.fetchall():
                sources = json.loads(row[2]) if row[2] else []
                history.append({
                    'user_query': row[0],
                    'ai_response': row[1],
                    'sources': sources,
                    'created_at': row[3]
                })
            
            return list(reversed(history))  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –≤ —Ö—Ä–æ–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–æ–º –ø–æ—Ä—è–¥–∫–µ
    
    def get_documents_stats(self) -> Dict:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞–º"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            
            # –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤
            cursor.execute('SELECT COUNT(*) FROM documents')
            docs_count = cursor.fetchone()[0]
            
            # –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —á–∞–Ω–∫–æ–≤
            cursor.execute('SELECT COUNT(*) FROM document_chunks')
            chunks_count = cursor.fetchone()[0]
            
            # –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —á–∞–Ω–∫–æ–≤ —Å embeddings
            cursor.execute('SELECT COUNT(*) FROM document_chunks WHERE embedding IS NOT NULL')
            embedded_chunks = cursor.fetchone()[0]
            
            return {
                'documents_count': docs_count,
                'chunks_count': chunks_count,
                'embedded_chunks': embedded_chunks,
                'embedding_progress': (embedded_chunks / chunks_count * 100) if chunks_count > 0 else 0
            } 